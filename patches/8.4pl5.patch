diff -u -N -r coq-8.4pl5/lib/pp.mli coq-8.4pl5+actor/lib/pp.mli
--- coq-8.4pl5/lib/pp.mli	2014-10-22 17:30:53.000000000 +0900
+++ coq-8.4pl5+actor/lib/pp.mli	2014-12-15 00:24:28.000000000 +0900
@@ -22,12 +22,12 @@
 
 (** {6 Formatting commands. } *)
 
-val str  : string -> std_ppcmds
+val str  : string -> std_ppcmds (* 文字列の出力 *)
 val stras : int * string -> std_ppcmds
 val brk : int * int -> std_ppcmds
 val tbrk : int * int -> std_ppcmds
 val tab : unit -> std_ppcmds
-val fnl : unit -> std_ppcmds
+val fnl : unit -> std_ppcmds    (* 改行の出力 *)
 val pifb : unit -> std_ppcmds
 val ws : int -> std_ppcmds
 val mt : unit -> std_ppcmds
@@ -64,7 +64,7 @@
 val h : int -> std_ppcmds -> std_ppcmds
 val v : int -> std_ppcmds -> std_ppcmds
 val hv : int -> std_ppcmds -> std_ppcmds
-val hov : int -> std_ppcmds -> std_ppcmds
+val hov : int -> std_ppcmds -> std_ppcmds (* 出力するやつを int だけインデント？ *)
 val t : std_ppcmds -> std_ppcmds
 
 (** {6 Opening and closing of boxes. } *)
diff -u -N -r coq-8.4pl5/plugins/extraction/common.ml coq-8.4pl5+actor/plugins/extraction/common.ml
--- coq-8.4pl5/plugins/extraction/common.ml	2014-10-22 17:30:53.000000000 +0900
+++ coq-8.4pl5+actor/plugins/extraction/common.ml	2014-12-14 21:42:13.000000000 +0900
@@ -569,6 +569,7 @@
       | Scheme -> unquote s (* no modular Scheme extraction... *)
       | Haskell -> if modular () then pp_haskell_gen k mp rls else s
       | Ocaml -> pp_ocaml_gen k mp rls (Some l)
+      | Erlang -> s
 
 (* The next function is used only in Ocaml extraction...*)
 
diff -u -N -r coq-8.4pl5/plugins/extraction/erlang.ml coq-8.4pl5+actor/plugins/extraction/erlang.ml
--- coq-8.4pl5/plugins/extraction/erlang.ml	1970-01-01 09:00:00.000000000 +0900
+++ coq-8.4pl5+actor/plugins/extraction/erlang.ml	2014-12-15 21:42:11.000000000 +0900
@@ -0,0 +1,240 @@
+open Pp
+open Names
+open Nameops
+open Util
+open Miniml
+open Mlutil
+open Common
+
+
+(* Erlang AST *)
+
+type erl_var = MkVar of identifier           (* 大文字始まり *)
+type erl_atom = MkAtom of string         (* アトム (identifier じゃなくて string のほうがいいかも) *)
+
+type erl_expr =
+  | ErlSeq of erl_expr * erl_expr (* ..., ... *)
+  | ErlBind of erl_var * erl_expr (* Var = ... *)
+  | ErlLam of erl_var list * erl_expr (* fun(A, B, ...) -> ... end *)
+  | ErlApp of erl_expr * erl_expr list (* 'f'(A), F(A, B, C), (fun X -> X)(A) など *)
+  | ErlCase of erl_expr * erl_branch list (* case ... of ... -> ...; ... -> ... end *)
+  | ErlReceive of erl_branch list        (* receive ... -> ...; ... -> ... end *)
+  | ErlThrow of erl_expr                 (* throw(e) *)
+  | ErlTuple of erl_expr list             (* {a, b, c} *)
+  | ErlList of erl_expr list              (* [a, b, c] *)
+  | ErlListCons of erl_expr * erl_expr    (* [a | b] *)
+  | ErlVar of erl_var     (*  *)
+  | ErlAtom of erl_atom   (* 'atom', 関数名も''でつつんでいいっぽい *)
+  | ErlString of string   (* "str" *)
+
+and erl_branch = erl_expr * erl_expr
+
+(* トップレベルパターンマッチはしない *)
+type erl_decl = ErlFun of erl_atom * erl_var list * erl_expr
+
+(* Pretty Printers for Erlang AST *)
+
+let pp_erl_var = function
+  | MkVar id -> str (String.capitalize (string_of_id id))
+let pp_erl_atom = function
+  | MkAtom s -> str (String.uncapitalize s) (* 最初の文字が小文字で、かつスペースや記号が入ってなかったら''でつつまないようにしたい *)
+
+let pp_erl_args f args =
+  pp_par true (prlist_with_sep (fun () -> str ", ") f args)
+
+let rec pp_erl_expr = function
+  | ErlSeq (e1, e2) -> pp_erl_expr e1 ++ str "," ++ fnl () ++ pp_erl_expr e2
+  | ErlBind (var, e) -> pp_erl_var var ++ str " = " ++ pp_erl_expr e
+  | ErlLam (args, body) -> str "fun" ++ pp_erl_args pp_erl_var args ++ str " -> " ++ pp_erl_expr body
+  | ErlApp (f, args) -> pp_par true (pp_erl_expr f) ++ pp_erl_args pp_erl_expr args
+  | ErlCase (e, bs) ->
+     str "case " ++ pp_erl_expr e ++ str " of" ++ fnl () ++
+       str "    " ++ hov 0 (prlist_with_sep (fun () -> str ";" ++ fnl ()) pp_erl_branch bs) ++ fnl () ++
+       str "end"
+  | ErlReceive bs ->
+     str "receive" ++ fnl () ++
+       str "    " ++ hov 0 (prlist_with_sep (fun () -> str ";" ++ fnl ()) pp_erl_branch bs) ++ fnl () ++
+       str "end"
+  | ErlThrow e -> str "throw(" ++ pp_erl_expr e ++ str ")"
+  | ErlTuple es -> str "{" ++ prlist_with_sep (fun () -> str ", ") pp_erl_expr es ++ str "}"
+  | ErlList es -> str "[" ++ prlist_with_sep (fun () -> str ", ") pp_erl_expr es ++ str "]"
+  | ErlListCons (h, t) -> str "[ " ++ pp_erl_expr h ++ str " | " ++ pp_erl_expr t ++ str " ]"
+  | ErlVar v -> pp_erl_var v
+  | ErlAtom a -> pp_erl_atom a
+  | ErlString s -> str "\"" ++ str s ++ str "\""
+
+and pp_erl_branch (pat, body) =
+  pp_erl_expr pat ++ str " ->" ++ fnl () ++
+    str "    " ++ hov 0 (pp_erl_expr body)
+
+let pp_erl_decl = function
+  | ErlFun (fname, args, body) ->
+     pp_erl_atom fname ++ pp_erl_args pp_erl_var args ++ str " -> " ++ fnl () ++
+       str "    " ++ hov 0 (pp_erl_expr body) ++ str "." ++ fnl2 ()
+
+(* AST Converters *)
+
+let array_zip xs ys = array_map2 (fun x y -> x, y) xs ys
+let map_id args = List.map id_of_mlid args
+
+let keywords =
+  List.fold_right
+    (fun s -> Idset.add (id_of_string s))
+    [ "module"; "export";
+      "fun"; "end"; "if"; "case"; "of"; "when";
+      "receive"; "after"; "try"; "catch" ]
+    Idset.empty
+
+(* pp_pattern : env -> int -> erl_expr *)
+(* num は変数の数 *)
+let rec conv_pattern env num = function
+  | Pcons (r, pats) ->
+     let c = ErlAtom (MkAtom (pp_global Cons r)) in
+     let es = List.map (conv_pattern env num) pats in
+     ErlTuple (c :: es)
+  | Ptuple pats -> ErlTuple (List.map (conv_pattern env num) pats)
+  | Prel n -> ErlVar (MkVar (get_db_name n env))
+  | Pwild -> ErlAtom (MkAtom "_")
+  | Pusual r -> (** Shortcut for Pcons (r,[Prel n;...;Prel 1]) **)
+     let rec n_to_1 n = if n < 1 then [] else n :: n_to_1 (n - 1) in
+     let pats = List.map (fun n -> Prel n) (n_to_1 num) in
+     conv_pattern env num (Pcons (r, pats))
+
+(* pp_branch : env -> ml_branch -> erl_branch *)
+let rec conv_branch env = function
+  | (ids, pat, a) ->
+     let ids', env' = push_vars (List.rev_map id_of_mlid ids) env in
+     (conv_pattern env (List.length ids) pat, conv_expr env a)
+
+(* pp_branches : env -> ml_branch array -> std_ppcmds *)
+and conv_branches env pats = Array.to_list (Array.map (conv_branch env) pats)
+
+(* pp_fix : env -> identifier array -> ml_ast array -> std_ppcmds *)
+(* https://twitter.com/ajiyoshi/status/544349185525297152 *)
+(* Erlang は関数本体の中で再帰関数を書けないので、Yコンビネータっぽいことをする。 *)
+(* example:
+ *
+ * let rec f a = f (g a) and g a = f a in ... (この例は停止しないけど)
+ *
+ * =>
+ *
+ * F_fix = fun(F_fresh, G_fresh, A) -> F_fresh(F_fresh, G_fresh, G_fresh(F_fresh, G_fresh, A)) end,
+ * G_fix = fun(F_fresh, G_fresh, A) -> F_fresh(F_fresh, G_fresh, A) end,
+ * F = fun(A) -> F_fix(F_fix, G_fix, A) end,
+ * G = fun(A) -> G_fix(F_fix, G_fix, A) end,
+ * ...
+ *)
+and conv_list_seq = function
+  | [] -> failwith "conv_list_seq: unexpected arguments"
+  | [e] -> e
+  | e :: es -> ErlSeq (e, conv_list_seq es)
+
+and conv_fix_one env ex_args fix_id def =
+  let args, body = collect_lams def in
+  let args', env' = push_vars (List.rev (map_id args)) env in
+  let ex_args', env'' = push_vars (List.rev ex_args) env' in
+  let erl_body = conv_expr env'' body in
+  ErlBind (MkVar fix_id, ErlLam (List.map (fun v -> MkVar v) (ex_args' @ args'), erl_body))
+
+and conv_fix_two fix_ids id fix_id def =
+  let args, _ = collect_lams def in
+  let args = map_id args in
+  ErlBind (MkVar id,
+           ErlLam (List.map (fun v -> MkVar v) args,
+                   ErlApp (ErlVar (MkVar fix_id),
+                           List.map (fun v -> ErlVar (MkVar v)) (fix_ids @ args))))
+
+and conv_fix env ids defs =
+  let to_fix id = id_of_string ((string_of_id id) ^ "_fix") in
+  let fix_ids = List.map to_fix ids in
+  let zipped = List.combine fix_ids defs in
+  let binds = List.map (fun (id, def) -> conv_fix_one env ids id def) zipped in
+  let binds' = List.map (fun (id, def) -> conv_fix_two fix_ids id (to_fix id) def) zipped in
+  conv_list_seq (binds @ binds')
+
+(* pp_expr : env -> ml_ast -> erl_expr *)
+and conv_expr env = function
+  | MLrel n ->                  (* 環境から de Bruijn index で入れた変数名を取り出す *)
+     (* let id = get_db_name n env in *)
+     let id = id_of_string "REL" in
+     ErlVar (MkVar id)           (* ここで出てくるのは変数名しかないよね？ *)
+  | MLapp (f, args) ->         (* 関数適用 *)
+     let f = conv_expr env f in
+     let args = List.map (conv_expr env) args in
+     ErlApp (f, args)
+  | MLlam _ as a ->             (* 無名関数 *)
+     let args, a' = collect_lams a in (* fun x -> fun y -> ... -> t を fun x y ... -> t にする *)
+     let args, env' = push_vars (List.rev (map_id args)) env in (* 環境に入れる *)
+     let args = List.map (fun v -> MkVar v) args in
+     ErlLam (args, conv_expr env' a')
+  | MLletin (id, a1, a2) ->     (* 局所束縛 *)
+     let i, env' = push_vars [id_of_mlid id] env in
+     let var = MkVar (List.hd i) in
+     let erl_a1 = conv_expr env a1 in
+     let erl_a2 = conv_expr env' a2 in
+     ErlSeq (ErlBind (var, erl_a1), erl_a2)
+  | MLglob r -> (* ??? トップレベルに定義してる名前とか？ *)
+     ErlAtom (MkAtom (pp_global Term r))
+  | MLcons (_, r, asts) ->      (* MLcons (型, コンストラクタ名, 引数) だと思う、たぶん *)
+     let c = ErlAtom (MkAtom (pp_global Cons r)) in
+     let es = List.map (conv_expr env) asts in
+     (* ここを actions と behavior のコンストラクタのときだけ別なように処理すればいい *)
+     ErlTuple (c :: es)
+  | MLtuple asts ->             (* タプル *)
+     let es = List.map (conv_expr env) asts in
+     ErlTuple es
+  | MLcase (_, a, pats) ->      (* パターンマッチ *)
+     let a = conv_expr env a in
+     let bls = List.map (conv_branch env) (Array.to_list pats) in
+     ErlCase (a, bls)
+  | MLfix (i, ids, defs) ->     (* 相互再帰 let rec f a = ... g ... and g a = ... g ... in ... *)
+     conv_fix env (Array.to_list ids) (Array.to_list defs)
+     (* pr_id ids.(i)              (\* <- ??? *\) *)
+  | MLexn s ->                  (* 例外 *)
+     ErlThrow (ErlString s)
+  | MLdummy -> ErlAtom (MkAtom "__")         (* ??? *)
+  | MLaxiom -> ErlThrow (ErlString "axiom")
+  | MLmagic a -> conv_expr env a  (* erlang に magic に対応するものってあんの *)
+
+(* preamble : identifier -> module_path list -> unsafe_needs -> std_ppcmds *)
+(* preamble で -export([Function1/Arity1,..,FunctionN/ArityN]) を出力したいが、関数名の情報は入力に含まれないので、モジュール名だけ出力する *)
+(* preamble の入力に関数名と引数の数が含まれるようなものを渡すように改造したほうがいいかもしれない *)
+let preamble mod_name used_modules usf =
+  str "-module(" ++ pr_id mod_name ++ str ")." ++ fnl2 ()
+
+(* Recursive Extraction のときに使われるっぽい *)
+let pp_struct = function
+  | _ -> str "[pp_struct]"
+
+(* haskell.ml の pp_function とほぼおなじ *)
+(* pp_function : global_reference -> ml_ast -> std_ppcmds *)
+let conv_function r lam =
+  let fname = MkAtom (pp_global Term r) in
+  (* collect_lams は mlutil.ml に定義されてて、
+   * fun x -> fun y -> fun z -> ... -> t みたいなのを、
+   * ([ x; y; z; ... ], t) にする
+   *)
+  let args, body = collect_lams lam in
+  let args, env = push_vars (map_id args) (empty_env ()) in
+  let args = List.map (fun v -> MkVar v) (List.rev args) in
+  let body = conv_expr env body in
+  ErlFun (fname, args, body)
+
+let pp_decl = function
+  | Dind (_, _) -> mt ()        (* Inductive は何も出力しない *)
+  | Dtype (_, _, _) -> mt ()    (* Type alias は何も出力しない *)
+  | Dterm (r, ast, _) -> pp_erl_decl (conv_function r ast)        (* 普通の関数定義 *)
+  | Dfix (rv, defv, _) ->    (* 相互再帰 (Erlang はトップレベルは相互再帰可能なので Dterm のときと同じ) *)
+     let _ = assert (Array.length rv == Array.length defv) in
+     prvect (fun (r, def) -> pp_erl_decl (conv_function r def)) (array_zip rv defv)
+
+let erlang_descr = {
+  keywords = keywords;
+  file_suffix = ".erl";
+  preamble = preamble;
+  pp_struct = pp_struct;
+  sig_suffix = None;
+  sig_preamble = (fun _ _ _ -> mt ());
+  pp_sig = (fun _ -> mt ());
+  pp_decl = pp_decl;
+}
diff -u -N -r coq-8.4pl5/plugins/extraction/erlang.mli coq-8.4pl5+actor/plugins/extraction/erlang.mli
--- coq-8.4pl5/plugins/extraction/erlang.mli	1970-01-01 09:00:00.000000000 +0900
+++ coq-8.4pl5+actor/plugins/extraction/erlang.mli	2014-12-14 21:38:00.000000000 +0900
@@ -0,0 +1 @@
+val erlang_descr : Miniml.language_descr
diff -u -N -r coq-8.4pl5/plugins/extraction/extract_env.ml coq-8.4pl5+actor/plugins/extraction/extract_env.ml
--- coq-8.4pl5/plugins/extraction/extract_env.ml	2014-10-22 17:30:53.000000000 +0900
+++ coq-8.4pl5+actor/plugins/extraction/extract_env.ml	2014-12-14 22:13:36.000000000 +0900
@@ -379,6 +379,7 @@
   | Ocaml -> Ocaml.ocaml_descr
   | Haskell -> Haskell.haskell_descr
   | Scheme -> Scheme.scheme_descr
+  | Erlang -> Erlang.erlang_descr
 
 (* From a filename string "foo.ml" or "foo", builds "foo.ml" and "foo.mli"
    Works similarly for the other languages. *)
diff -u -N -r coq-8.4pl5/plugins/extraction/extraction_plugin.mllib coq-8.4pl5+actor/plugins/extraction/extraction_plugin.mllib
--- coq-8.4pl5/plugins/extraction/extraction_plugin.mllib	2014-10-22 17:30:53.000000000 +0900
+++ coq-8.4pl5+actor/plugins/extraction/extraction_plugin.mllib	2014-12-14 22:16:26.000000000 +0900
@@ -6,6 +6,7 @@
 Ocaml
 Haskell
 Scheme
+Erlang
 Extract_env
 G_extraction
 Extraction_plugin_mod
diff -u -N -r coq-8.4pl5/plugins/extraction/g_extraction.ml4 coq-8.4pl5+actor/plugins/extraction/g_extraction.ml4
--- coq-8.4pl5/plugins/extraction/g_extraction.ml4	2014-10-22 17:30:53.000000000 +0900
+++ coq-8.4pl5+actor/plugins/extraction/g_extraction.ml4	2014-12-14 21:43:53.000000000 +0900
@@ -43,12 +43,14 @@
   | Ocaml -> str "Ocaml"
   | Haskell -> str "Haskell"
   | Scheme -> str "Scheme"
+  | Erlang -> str "Erlang"
 
 VERNAC ARGUMENT EXTEND language
 PRINTED BY pr_language
 | [ "Ocaml" ] -> [ Ocaml ]
 | [ "Haskell" ] -> [ Haskell ]
 | [ "Scheme" ] -> [ Scheme ]
+| [ "Erlang" ] -> [ Erlang ]
 END
 
 (* Extraction commands *)
diff -u -N -r coq-8.4pl5/plugins/extraction/table.ml coq-8.4pl5+actor/plugins/extraction/table.ml
--- coq-8.4pl5/plugins/extraction/table.ml	2014-10-22 17:30:53.000000000 +0900
+++ coq-8.4pl5+actor/plugins/extraction/table.ml	2014-12-14 21:45:30.000000000 +0900
@@ -534,7 +534,7 @@
 
 (*s Extraction Lang *)
 
-type lang = Ocaml | Haskell | Scheme
+type lang = Ocaml | Haskell | Scheme | Erlang
 
 let lang_ref = ref Ocaml
 
diff -u -N -r coq-8.4pl5/plugins/extraction/table.mli coq-8.4pl5+actor/plugins/extraction/table.mli
--- coq-8.4pl5/plugins/extraction/table.mli	2014-10-22 17:30:53.000000000 +0900
+++ coq-8.4pl5+actor/plugins/extraction/table.mli	2014-12-14 21:45:57.000000000 +0900
@@ -133,7 +133,7 @@
 
 (*s Target language. *)
 
-type lang = Ocaml | Haskell | Scheme
+type lang = Ocaml | Haskell | Scheme | Erlang
 val lang : unit -> lang
 
 (*s Extraction modes: modular or monolithic, library or minimal ?
@@ -192,6 +192,3 @@
 val extraction_blacklist : identifier list -> unit
 val reset_extraction_blacklist : unit -> unit
 val print_extraction_blacklist : unit -> unit
-
-
-
